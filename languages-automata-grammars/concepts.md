# 形式语言、形式语法和自动机

## 字母表，字符串，自由半群

字母表：非空符号集合（通常记作A）
字符串：字母表元素中的有限序列（通常记作 w, u, v）
空串：没有字符的序列（通常使用希腊字母 lambda 或 epsilon表示）

A 中所有字符串的集合记为 A*（读作 A 星）

字符串长度：记作 |u| 或 l(u)，表示字符串u中字符的个数。l(\lambda) = 0.

### 连接

对于字母表A中的两个字符串 u 和 v，连接 u 和 v 记作 uv，表示字符串 v 紧接着写在字符串 u 之后。

定理13.1 字母表A中的字符串的连接运算满足结合律，空串是运算中的单位元。
（一般地，运算的交换律不成立）

### 子串，前缀

子串：对于任意字符串 u = a1 a2 ... an,任何序列 w = a_ {j} a_ {j+1} ... a_k 称作u的子串。
前缀：子串 w = a1 a2 ... ak，以u的字符开头，称作 u 的前缀。

### 自由半群，自由幺半群

自由半群：用F表示字母表A中所有非空字符串的集合，并且含有连接运算。由于连接运算满足结合律二，因此F是一个**半群**。
称作A的自由半群 或 由A 生成的自由半群。
当需要标明集合A时，A的自由半群记作 F_A。

自由幺半群：设 M = A* 是包括空串lambda在内的A中所有字符串的集合。由于lambda是连接运算的单位元，M是含幺半群，我们称M为A上的自由幺半群。

$$
F_A = A^* - \{\lambda\}
$$

## 形式语言

形式语言：字母表 A 上的形式语言 L 是 A 中的字符串的集合。因此，形式语言 L 是 A* 的一个子集。

### 形式语言的运算

假设 L 和 M 是 A 的形式语言，那么 L 和 M 的连接，记为 LM，是 A 上的一种形式语言，定义如下：

$$
LM = {uv: u \in L, v \in M}
$$

形式语言的幂：形式语言 L 的幂定义如下：

$$
L^0 = \{\lambda\}, L^1 = L, L^2 = LL, L^{m + 1} = L^mL(m > 1)
$$

一元运算 L* （读作 “L星”），称作 L 的 Kleene 闭包，
$$
L^* = L^0 \cup L^1 \cup L^2 \cup \cdots = \cup_{k = 0}^{\infty} L^k
$$

定理13.2 L* 的定义与 A* 一致。

此外，记号 L+ 表示：
$$
L^+ = L^* - L^0
$$

## 正则表达，正则语言

**定义** 下面每一项均为字母表A中的正则表达：

    1. 符号\lambda（空串） 和括号()（空表达）是正则表达；
    2. A中每个字母a是正则表达
    3. 如果r是正则表达，那么(r*)是正则表达
    4. 如果 r1 和 r2 是正则表达，那么 (r1 \lor r2)是正则表达；
    5. 如果 r1 和 r2 是正则表达，那么 (r1r2) 是正则表达；

  注意： 正则表达r 是一种特殊的字符串，它用A中的字符和如下五种符号：
$$
  ( ) * \lor \lambda
$$
  此外，没有其它符号用于正则表达。

**定义** A 上的形式语言 L(r) 由正则表达 r 定义如下：
    1. L(\lambda) = {\lambda} 和 L(()) = \emptyset（空集）
    2. L(a) = a，其中 a 是 A 中的字符串
    3. L( r* ) = (L(r))* ；L(r) 的 Kleen闭包
    4. L(r1 \lor r2) = L(r1) \cup L(r2)； 形式语言的并集
    5. L(r1 r2) = L(r1)L(r2) (形式语言的连接)

**定义** 设 L 为 A 的形式语言，若存在 A 上的一正则表达式，使得 L = L(r)，则L称为 A 的正则语言。

## 有限自动机

有限自动机(FSA)，或者简单地说，自动机 M，由下述五部分组成：
    1. 一个有限的输入集合A（字母表）
    2. （内部的）一个有限状态集合S
    3. S 的一个子集Y（Y的元素称为接受状态, yes）
    4. S的初始状态s_0
    5. S中的状态转移函数 F:S \times A -> S

当要指明它的五部分时，自动机M被记为：
$$
M = (A, S, Y, s_0, F)
$$

状态转移函数：
对每个 a \in A，定义 f_a: S \to S；即每一个输入a可看作引起自动机 M 的状态改变。
F(s, a) = f_a(s) 表示两个定义是等价的。

### 自动机 M 的状态图

自动机通常使用它的状态图 D = D(M) 来定义，而不是列出它的五个部分。状态图 D = D(M) 是如下的一种带标记的有向图。
    1. D(M) 的结点是 S 的状态，接受状态用双圈表示
    2. 在 D(M) 中，若 F(s_ j, a) = s_ k 或 f_ a(s_ j) = s_ k，则用一个标有输入a的箭头从 s_ j 指向 s_ k
    3. 初始状态 s_ 0 是通过一特殊的箭号表示，这个箭号终止于 s_ 0，但是没有初始结点。

### 自动机 M 决定的形式语言 L(M)

每一个有输入字母表 A 的自动机 M 定义 A 上的一种形式语言 L(M) 如下：
设 w = a1 a2 ... am 为A中的一字符串，则 w 确定一状态序列：

$$
s_0 \to s_1 \to s_2 \to \cdots \to s_m
$$

其中 s_0 为初始状态且 F(s_{i - 1}, a_i) = s_i(i >= 1)， 换句话说，w确定了状态图 D(M) 的路径：
$$
P = (s_0, a_1, s_1, a_2, s_2, \cdots, a_m, s_m)
$$

如果最后状态 s_m 是 Y 中的接受状态，则说 M 识别字符串 w。
M 的形式语言 L(M) 为 A中被 M 接受的所有字符串的集合。

定理 13.2（Kleene） 字母表 A 上的形式语言 L 是正则的当且仅当存在一个有限自动机 M 使得 L = L(M)。

（形式语言 L 上的 * 运算 L* 有时称作 L 的 Kleene 闭包）。

### Pumping引理

定理13.3 （Pumping引理） 假设 M 是 A 上的自动机并满足：
    1. M 有 k 个状态
    2. M 接受 A 的字符串 w，这里 |w| > k
  那么 w = xyz，这里对每一个正整数m，w_m = xy^m z 被 m 接受。

## 形式语法

一个**短语结构形式语法**，简称形式语法G，由四个部分构成：
    1. 一个有限集（**词汇**）V；
    2. V 的一个子集T，T 的元素称为**终结元**；集合 N = V\T 的元素称为 **非终结元** 或 **变元**；
    3. 一个非终结符 S 称为**起始符**；
    4. 一个产生式的有限集 P。产生式是一个有序偶(\alpha, \beta)，通常记作 \alpha \to \beta， 其中\alpha，\beta是 V 上的字符串；P 中的每个产生式的左端必须至少包括一个非终结元。
  这样的形式语法 G，记作 G = G(V, T, S, P)

除特别说明外，形式语法用下面的记法：终结元用斜体小写拉丁字母表示；非终结元用斜体大写拉丁字母表示；起始符用 S 表示；同时，V 中的字符串，即终结元 或 非终结元 的字符串用希腊字母表示，此外，将：
$$
\alpha \to \beta _1, \alpha \to \beta _2, \cdots, \alpha \to \beta _k
$$
记作：
$$
\alpha \to (\beta _1, \beta _2, \cdots, \beta _k)
$$

### 形式语法 G 的形式语言 L(G)

假设 w 和 w' 是形式语法 G 的词汇集合 V 上的字符串，如果 w' 能够由 w 通过使用一个产生式得到，我们写成：
$$
w \Rightarrow w'
$$

即，如果存在字符串 u 和 v，使得 w = u \alpha v 且 w' = u\beta v，并且有一个产生式 \alpha \to \beta，我们写成：
$$
w \Rightarrow \Rightarrow w', w^* \Rightarrow w'
$$
如果 w' 能够由 w 通过使用有限个产生式得到。

设 G 是一个形式语法，T 是 G 的终结元集。G 的形式语言，记作 L(G)；由初始符 S 通过以上过程得到 T 上的字符串组成，即：
$$
L(G) = \{ w \in T^*: s \Rightarrow\Rightarrow w \}
$$

### 形式语法的类型

#### Noam Chomsky分类法

形式语法根据所允许的产生式的种类来分类。
以下是 Noam Chomsky 提出的形式语法的分类：
    0. 一个零型形式语法在产生式上没有限制；
    1. 第一类型：如果形式语法 G 所有的产生式都是
$$
  \alpha \to \beta(|\alpha| \leq |\beta|), \alpha \to \lambda
$$
  2. 第二类型：如果形式语法 G 所有的产生式都是
     $$
     A \to \beta
     $$
     即其中左端是一个非终结元的形式

  3. 第三类型：如果形式语法 G 所有的产生式都是：

  4. $$
     A \to a, A \to aB, S \to \lambda
     $$
     即左端是一个非终结元，右端是一个终结元或一个终结元后跟一个非终结元；或起始符到空串。

可以看出，形式语法分类形式一个阶层组织，即第三类型的形式语法都是第二类型的；第二类型的形式语法都是第一类型的；第一类型的形式语法都是零类型形式语法。

#### 上下文相关性分类

形式语法也可以分类成上下文有关的法语、上下文无关的语法、正则的语法：

1. **上下文相关的语法**：一个形式语法 G，如果它的产生式都是：
$$
\alpha A \alpha ' \to \alpha \beta \alpha '
$$
称它是“上下文相关的”，是因为只有当变元A 在 \alpha 与 \alpha' 之间时，才总可以用\beta来取代A。

2. **上下文无关的语法**： 一个形式语法 G，如果它的产生式都是：
$$
A \to \beta
$$
称它为“上下文无关的”，是因为无论变元A在什么位置，我们总可以用 \beta 来取代 A。

3. **正则的语法**：一个形式语法是正则的，如果它的产生式都是这样的形式：
$$
A \to a, A \to aB, S \to \lambda
$$

可以看出，上下文无关的形式语法与第二类型形式语法是第个的，正则形式语法与第三类型形式语法是等价的。

**定理13.4** 形式语言 L 能由第三类型（正则）形式语法 G 生成，当且仅当存在一个有限自动机 M 能够接受 L。
因此，一个形式语法是正则的，当且仅当 L = L(r)，其中r 是正则表达式；当且仅当 L = L(M)，其中 M 是有限状态自动机；当且仅当 L = L(G)，其中 G 是正则形式语法。

### 上下文无关语法的导出树

**导出树**：一个上下文无关的形式语法G，L(G) 中的字符串 w 的导出可以用有序、有根的树 T 来形象地描述，称为导出树。

### Backus-Naur形式

在描述上下文无关的形式语法（第二类型形式语法）的产生式时，有时也用另外一种词法，称作 Backus-Naur形式。它的特点在于：

  1. 不用 \to 而用 ::= ；
  2. 非终结元要用 <> 括起来；
  3. 所有左端有相同非终结元的产生式要合并成一句，所有的右端在 ::= 的右边列出并用短竖隔开；

### 自动机与形式语法

正则形式语法对应有限状态自动机（FSA）。此外，还有其他形式的自动机，对应其他形式的语法。
  1. **Pushdown自动机**：Pushdown自动机 P 与 FSA 类似，且 P 有一个辅助储存器能为它提供无限大容量的存储空间。
    形式语言L能被Pushdown自动机识别，当且仅当 L 是 *上下文无关* 的形式语言。
  2. **线性有界自动机**：线性有界自动机 B 比 Pushdown自动机的功能更强，这样的自动机 B 使用一种带子，这种带子是根据输入字符串 w 的字长而线性有界的。
     形式语言L 能被自动机B识别当且仅当 L 是 *上下文有关* 的。
  3. **Turing自动机**：Turing自动机，使用的是一种无限长的带子，它能识别由任何短语结构形式语法 G 生成的所有形式语言。   事实上，Turing自动机 M 是一系列定义可数函数的等价方法中的一种。

## 有限状态机

有限状态机（FSM）与有限状态自动机（FSA）类似，只是FSM输出时使用一种与输入字母表不同的输出字母表。正式定义如下：
有限状态机（或完全序列机）M由六个部分组成：
  1. 一个输入符的有限集 A
  2. 一个内部状态的有限集 S
  3. 一个输出符的有限集 Z
  4. S 中的一个初始状态 s_0
  5. 一个从 S\times A 到 S 状态转移函数 f
  6. 一个从 S\times A 到 Z 的输出函数 g
这样的一个机器 M 被记作
$$
M = M(A, S, Z, s_0, f, g)
$$

### 有限状态机的状态表与状态图

描述有限状态机的方法通常有两种：一种是用表格，称作有限状态机 M 的状态表；另一种是用有标记的有向图，称作有限状态机的状态图。

**状态表**：状态表把状态转移函数 f 与 输出函数 g 放在同一个表格内，这个表格描述了由
$$
F(s_i, a_j) = (f(s_i, a_j), g(s_i, a_j))
$$
定义的函数
$$
F:S\times A \to S \times Z
$$

**状态图**：有限状态机 M = M(A, S, Z, s_0, f, g) 的状态图 D = D(M) 是一个有标记的有向图。D的结点是M的状态。此外，如果：
$$
F(s_i, a_j) = (s_k, z_r)
$$
亦即：
$$
f(s_i, a_j) = s_k \land g(s_i, a_j) = z_r
$$
那么，从 s_i 到 s_k 就有一条标着 a_j 和 z_r 的箭头。我们通常放输入符 a_j 靠近箭头的始端（靠近 s_i），输出符 z_r 靠近箭头的中心。此外，还通过另外画一条指向 s_0 的箭头来标记初始状态 s_0。

### 输入与输出带

设定给 M 一个输入符的字符串，如：
$$
u = a_1 a_2 \cdots a_m
$$
我们设想这些符号在一条“输入带”上，机器M一个一个地读这些输入符，同时进行一系列的状态转换：
$$
V = s_0 s_1 s_2 \cdots s_m
$$
其中 s_0 是初始状态，并且把输出符的字符串
$$
w = z_1 z_2 \cdots z_m
$$
打印在一条“输出带”上。准确地说，初始状态 s_0 和输入字符串 u 通过
$$
s_i = f(s_{i - 1}, a_i), z_i = g(s_{i - 1}, a_i)
$$
来决定字符串 v 和 w，其中 i = 1, 2, ..., m。
